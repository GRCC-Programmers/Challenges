These are my notes on the Knights Tour and Sudoku problem. The first step to solving a problem is to identify the problem and the second 
is to identify the steps involved. The problem is basically, I am trying to solve a 9x9 Sudoku board and 9x9 Knight's Tour. 
A "Knight's Tour" is a type of problem where the knight must traverse a board of n^2 size, touch every square, and never retouch another 
square. There are three possibilities, the tour can end on the square it started, the tour can end on a square where it didn't start, 
and no solution. Even when one sort of solution exists, the other may not. It is important to note though, that someone analyzed this 
problem enough to create a piecewise function determining the outcome of an attempted tour based on n.[1]

There are parts of the problem I can essentially ignore, including solving either board since programs and algorithms already exist. 
The most popular ones based on what I have found are an implementation of the Dancing Links algorithm created by Don Knuth, and the 
Warnsdorff Algorithm, which seeks to choose Knight's Tours moves based on which one will have the least subsequent moves to satisfy a 
valid answer. However, according to another academic paper[2] Warnsdorff's Algorithm runs in linear time. You can think of this as being 
a(n), where n is the amount of checks required to solve the problem and a is the constant variable. Computer scientists would typically 
prefer log(n) but that is not always possible. Even in cases where it is possible computer scientists have not always found the algorithm
that satisfies this runtime. However, if you're familiar with log graphs you can probably already tell it would scale better as n grows.
The algorithm for each move performs up to 8 checks for each possible move in each scenario. For smaller boards this is fine but will 
quickly become a problem. As a result, I need to find a solution that does not require such a massive board.

Therefore, a possible solution is to break down the board into several "smaller" boards that are connected or glued together. However, 
with this approach things get complicated very quickly. You must keep track of every knight's move and ensure each move would still 
satisfy the requirement. Furthermore, the rules asked for the output of 9x9 boards, so it must also look right when output. My solution 
involved simple math around a complicated topic.

Let n = number of squares
a1 = Number of indices of array 1
a2 = Number of indices of array 2

n = 9^2
n = 81

81 = (3x20) + (3x7)
81 = (3x10) + (3x10) + (3x7)

It is important that this math adds up correctly because it means I can let a1 = (3x20) or 60, and a2 = (3x7) or 21 with no loss of 
squares because in this case each index would represent an individual square. While Warnsdorff's Algorithm runs in linear time, many 
operations involved in "gluing" together any solutions will run at a constant or slightly quicker linear rate. However, I also must be 
careful because it is easy for this problem to get an exponential runtime, which scales very poorly. Which is why instead of physically 
gluing them together in memory it is probably more efficient to work through them as though they are a single array. Gluing them
however, could simply consist of starting the move counter at the last value of the last array. 

For example:
a1 = 0-59
a2 = 60,80

As long as 60 is a legal move from 59 and would be represented as such on the output it is legal and fine.

Furthermore, all of this work is done on the Cartesian coordinates plane. Every move is made relative of a given position on the board
and Warnsdorff's Algorithm reflects this in how it processes movements. Using a 2d array typically makes this math much more easy
because it is straightforward. However, there is another solution. Rather than representing the board in multiple 2d arrays,
with a little math and clever work I can knock down the array requirement. A pattern I have only recently noticed that works well for
this problem is that the concatenation of coordinates would give the index of a coordinate on a 2d plane.

(0,0) 
'0' + '0' = 00
(2,1)
'2' + '1' = 21

This is only a little impractical due to the values under 10, but removal of the leading zero in that case is easily performed with logic.
Since all moves are represented as changes in coordinates in Warnsdorff's algorithm it would make no difference in the end result. 

For example, if I wanted to move 2 spaces up and one space to the right from (2,1), I could do the following operation:
(2,1)
2 + 2 = 4
1 + 1 = 2
Then I concatenate the results:
'4' + '2' = 42
Which corresponds with: (4,2).

This idea is attractive because it introduces the possibility of using a BST (Binary Search Tree) instead of a vanilla array, where
the key is the set of coordinates and the value is the move of the knight. While BSTs can be rather complex the boards could be 
glued together with a negligible performance cost, due to the highly optimized runtime of BSTs. This would make comparison later on
quicker than searching an unsorted array and make the whole process far easier later on. Furthermore, using coordinates for keys instead
of values allows us to use a BST for Sudoku too without fear of repeating values. Then when I compute score I'll just compare keys of
each BST and get the value from the Sudoku BST.

The only downside I see is that the value would be redundant because of the use of a BST. However, searching through an unsorted array
could take many loops to compare all the values. Whereas, this way I can make a single run through a BST without having to implement
a sort algorithm independent of the array. While it may seem like more work it is actually a lot less than what the equivalent with
an array would require. For example, even though quicksort is very quick it would require a fully array before it could run.
Furthermore, it is independent of the array and unless I use a string array or a custom object array the value or key is lost, assuming
I seek to avoid a 2d array. I imagine you could quicksort a 2d array, I never have, and I don't think I want to if I can avoid it.
However, if quicksort or a good sorting array would be broken by a 2d array or nd array, where n > 1 then BSTs require serious
consideration because overall it is going to work better than a 1d array and quicksort for this operation. 

There is also the cost of memory, I suppose, but it comes out to a whole 324 bytes. Unless I remember incorrect an integer
is just 4 bytes and there would be 81 redundnat integers. That is a very small footprint for a data structure that remains sorted upon
insertion and is highly efficient as a search tool. Although, it is likely I will lean more towards the guarantee of a BST with a
runtime of N rather than 1.39 log N, due to its final geometric shape. Unless, I choose to balance the tree by choosing the 40th 
coordinate pair and separating things by whether they are larger or smaller than 40. In this case the use of value as the move of the 
knight is no longer redundant, either. Since in that case I could no longer rely on the position of the node within the tree. The end 
result should also get us closer to the average of 1.39 log N, instead of N. Of course, I am assuming that the tour will not start in 
the middle of the board. IFF it does then we will verge closer to the guarantee, but in that case I can also implement logic I imagine
to change the coordinate pair of the root node. 
                                                          (4,0)
                                                          /   \
                                                      (3,9)    (4,1)
                                                       /  \     /  \
                                                    (3,8)(3,7)(4,2) (4,3)
                                                    
                                               |0|   |1|   |2|   |3|   |4|   |5|   |6|
                                             |(4,0)|(3,9)|(3,8)|(3,7)|(4,1)|(4,2)|(4,3)|
                                                    
                                             The same dataset represented a BST and an array. In the order of which the data would be
                                             accessed in the BST. The coordinate pairs represent nodes in the BST and (4,0) is the BST's
                                             root node. In the array they represent an element. The zero-based index of each element
                                             in the array is denoted above it and encapsulated in pipes.
                                             I am going purely off memory so I might have the diagram off a little bit because I cannot
                                             remember if BSTs favor left or right. If you can ignore that little detail I think the 
                                             information is still mostly correct and works well enough for demonstration of the 
                                             difference.
                                                    
An iterated value is also required to ensure the comparison is done correctly. We can use an iterated count to compare against
values, even though this is not necessarily the default use of a BST. However, this is not as cumbersome as a 2d array or 
 as worrisome as relying on the unsorted or implied by its index order of moves later on when we go to compare coordinate pairs.

For example:

class Coordinates {
//initializing variables
int x = 0;
int y = 0;

void moveUpTwoRightOne() {}

void moveUpTwoLeftOne() {}

... and so on for all 8 possible moves.
}

However, once I solve the Knight's Tour, assuming I have already solved the Sudoku board the only task would be to compare coordinates 
against one another. If I are careful here though I can keep the runtime down low enough that a laptop such as mine can solve the 
problem. 

The fact we have to be concerned about runtime performance and the similarities in terms of data structures of Sudoku boards and 
Knight's Tours boards means this may also provide an easier way to compare coordinates and calculate the final score of the program.
Furthermore, you could create a method within the class to set the values of each Sudoku square, if you're concerned about having
no other use for the class outside of calculation of the final score. Really though, there would be nothing stopping you from making
very readable and functional code. I think.

Lastly, the issue of outputting a 9x9 board comes up because I am using 3xn boards. I believe that it is possible to daisy chain 3x3 
boards like how Sudoku is solved. Thereby giving the impression of a board that does not actually exist. 
This actually makes the problem far more approachable than it may initially seem.

Sources:
[1] http://gaebler.us/share/Knight_tour.html
[2] http://math.oregonstate.edu/~math_reu/proceedings/REU_Proceedings/Proceedings2004/2004Ganzfried.pdf
